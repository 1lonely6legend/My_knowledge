## 我自己的一些理解

std::mutex pnc_map_mutex_;我理解这个互斥锁就是一个通用的锁,_

这个其实跟pnc_map_变量没有关系_

_,我只是每次要使用pnc_map_时,

在前面加上这个锁,如果是其他变量,

使用这个锁也可以正确起到作用

相当于买了一把锁,我锁到哪一个门上也可以用,跟是哪一个房子没有关系,只不过我现在这个房子就拿这个锁一直用,所以起了一个一样的名字,

但是,现在把锁拿下来放到别的房子上也可以用

## mutex介绍

互斥量（Mutex）是一种同步原语，用于实现多线程环境下的互斥访问。它是一种线程同步的机制，用于保护共享资源，以防止多个线程同时访问或修改该资源而导致不确定的行为或数据损坏。

在多线程编程中，当多个线程同时访问共享资源时，可能会出现竞态条件（Race Condition），即多个线程在不同的时间点并发地对共享资源进行读取或写入操作。这样的竞态条件可能导致数据的不一致性或错误的结果。

互斥量提供了一种机制，允许线程独占地获取对共享资源的访问权。当一个线程获得互斥量的锁时，其他试图获取锁的线程将被阻塞，直到持有锁的线程释放锁。这样就确保了同一时间只有一个线程能够访问共享资源，从而避免了竞态条件。

互斥量的基本操作是锁定（lock）和解锁（unlock）：

- 锁定：当一个线程获得互斥量的锁时，它可以继续执行临界区代码，即对共享资源的访问和修改。
- 解锁：当线程完成对共享资源的操作后，应该释放互斥量的锁，以便其他线程能够获取锁并访问共享资源。

## std::mutex< >()

C++ 标准库提供了 `<mutex>` 头文件，其中定义了多种类型的互斥量，例如 `std::mutex`、`std::recursive_mutex`、`std::timed_mutex` 等。开发人员可以根据需求选择适合的互斥量类型来实现线程安全的访问。

需要注意的是，正确使用互斥量需要遵循一些规则，例如在访问共享资源之前获取锁，在访问完成后释放锁，避免锁的持有时间过长，避免死锁等。同时，互斥量的性能开销较大，因此应谨慎使用，并考虑其他同步机制的选择，如条件变量、读写锁等，以提高程序的性能和可伸缩性。

`std::lock_guard` 是 C++ 标准库中的一个模板类，用于提供一种方便的方式来管理互斥量（mutex）的锁定和解锁操作。它是在 C++11 中引入的，位于 `<mutex>` 头文件中。

`std::lock_guard` 的主要目的是在创建 `std::lock_guard` 对象时自动获取互斥量的锁，并在对象生命周期结束时自动释放锁。这种自动化的锁定和解锁机制有助于避免忘记释放锁而导致的死锁问题。

`std::lock_guard` 的构造函数接受一个互斥量作为参数，并在构造时锁定该互斥量。当 `std::lock_guard` 对象销毁时（例如离开作用域），它会自动释放互斥量的锁。这样可以确保在任何情况下都能正确释放锁，包括在函数返回、异常抛出或提前退出时。

以下是 `std::lock_guard` 的基本用法示例：

```cpp
#include <iostream>
#include <mutex>

std::mutex mtx;  // 创建一个互斥量

void foo()
{
    std::lock_guard<std::mutex> lock(mtx);  // 锁定互斥量

    // 在这里执行受互斥量保护的操作
    // 互斥量在离开作用域时会自动释放锁
}

int main()
{
    foo();
    return 0;
}
```

在上面的示例中，`std::lock_guard` 对象 `lock` 在函数 `foo` 内部创建并锁定了互斥量 `mtx`。无论函数 `foo` 是正常返回还是由于异常退出，`std::lock_guard` 对象 `lock` 在离开作用域时都会自动释放互斥量的锁。

`std::lock_guard` 的一个重要特性是其非复制构造函数和非复制赋值运算符。这意味着 `std::lock_guard` 对象不能被复制或赋值，从而防止了多个 `std::lock_guard` 对象同时持有同一个互斥量，从而导致死锁。

总而言之，`std::lock_guard` 提供了一种简单且安全的方式来管理互斥量的锁定和解锁操作，有助于避免忘记释放锁而导致的潜在问题。

