# static、const 与初始化

>https://zhuanlan.zhihu.com/p/141113043
>https://blog.csdn.net/tobefxz/article/details/14109697

## static

### 1.控制存储方式

static被引入以告知编译器，将变量**存储在程序的静态存储区**而非栈上空间。

> 　1、引出原因：函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，**函数在栈上分配的空间在此函数执行结束时会释放掉**，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？
> 　
> 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。
> 
>		2. 解决方案：因此c++ 中引入了static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的存取范围不变。

### 2.控制可见性与连接类型

static还有一个作用，它会把变量的可见范围限制在编译单元中，使它成为一个内部连接，这时，它的反义词为”extern”.

内部链接、外部链接例子：

```cpp
int giants = 5;　　　　　　　// 文件作用域，外部链接
static int dodgers = 3;　　 // 文件作用域，内部链接
int　main(){
...
}
//该文件和同一程序的其他文件都可以使用变量giants。
//而变量dodgers属文件私有，该文件中的任意函数都可使用它。
```

static作用分析总结：**static总是使得变量或对象的存储形式变成静态存储**，连接方式变成内部连接，对于局部变量（已经是内部连接了），它仅改变其存储方式；对于全局变量（已经是静态存储了），它仅改变其连接类型。

### 类中使用static数据成员的作用

#### 出现原因

1.需要在一个类的各个对象间交互，即需要一个数据对象**为整个类而非某个对象服务**。**static数据成员在各个对象中是互通的。**
2.同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。

类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。

#### 类中使用static的注意事项

1.对于静态的数据成员，连接器会保证它拥有一个单一的外部定义。**静态数据成员按定义出现的先后顺序依次初始化**，注意**静态成员嵌套时，要保证所嵌套的成员已经初始化了**。消除时的顺序是初始化的反顺序。
2.**类的静态成员*函数*是**属于整个类而非类的对象，所以它**没有this指针**，这就导致了它**仅能访问类的静态数据和静态成员函数**，并且**不能被声明为virtual**

## const

### c++的一些特点

1.c++有一个类型严格的编译系统，这使得**c++程序的错误在编译阶段即可发现许多**，从而使得出错率大为减少。
2.c中很常见的预处理指令 **#define variablename variablevalue** 可以很方便地进行值替代，这种值替代至少在三个方面优点突出.

#### 预处理指令的优点

1.避免了意义模糊的数字出现，使得**程序语义流畅清晰**，如下例：#define user_num_max 107 这样就避免了直接使用107带来的困惑。
2.可以很**方便地进行参数的调整与修改**，如上例，当人数由107变为201时，进改动**预处理定义**即可。
3.**提高了程序的执行效率，**由于使用了预编译器进行值替代，并不需要为这些常量分配存储空间，所以执行的效率较高。

### C++为什么要引入const

由上述C++的特点：

>预处理语句虽然有以上的许多优点，但它有个比较致命的缺点，即，**预处理语句仅仅只是简单值替代**，缺乏类型的检测机制。这样预处理语句就**不能享受c++严格类型检查的好处**，从而可能成为引发一系列错误的隐患。

所以得出c++引入const的目的

onst 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。

#### const代替#define的优点

1.以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。

2.很明显，它也同样可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。

3.c++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高，同时，这也是它取代预定义语句的重要基础。这里，我要提一下，为什么说这一点是也是它能取代预定义语句的基础，这是因为，编译器不会去读存储的内容，如果编译器为const分配了存储空间，它就不能够成为一个编译期间的常量了。（？没看懂）

4. 最后，const定义也像一个普通的变量定义一样，它会由编译器对它进行类型的检测，消除了预定义语句的隐患。

### const的使用情况

1.const用于指针（常量指针和指针常量）

我就记得**const右边哪个量，哪个就是不变量**

```cpp
//常量指针
int const *a; 　file://a可变，*a不可变 
//const更靠近*，代表*a不变，a可变，
//指针指向的地址可以变，但不可以通过指针改变指向的值

//指针常量，在定义的同时必须初始化
int *const a; 　file://a不可变，*a可变 
//const更靠近a，代表a不变，*a可变，
//指针指向的地址不可以变，但可以通过指针改变指向的值
```

2.const 限定函数的传递值参数

```cpp
　void fun(const int var);
```

分析：上述写法**限定参数在函数体中不可被改变**。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。

结论：**最好在函数的内部进行限定，对外部调用者屏蔽**，以免引起困惑。如可改写如下：

```cpp
void fun(int var){
	const int & varalias = var;

	varalias ....

	.....
} 
```

3.const 限定函数的值型返回值：

```cpp
const int fun1(); 
const myclass fun2();
```

分析:上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。（？没看懂）

4.传递与返回地址： 此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。

5.const 限定类的成员函数：

```cpp
class classname {
　public:
　　int fun() const;
　.....
}
//获得能力：可以操作常量对象。
//失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。
```

注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。

### const总结

1. 函数返回值为const时，返回的东西赋给一个类型相同的标示后其不能为左值；不可被改变
2. 用const定义的int可用来开辟数组，但const定义的常量数组中的元素，不能用来定义数组。
3. const int *i; int const *i; int * const i; 前两个功能相同，说明I所指向的内容不变；最后一 个说明指针指向的地址不变，但内容可变。
4. 类中的const成员函数,定义为在原型后加const。常量函数不能修改类中的任何属性。但有两种方法可 以修改。
>1. {(yourclass *)this->member = values;}
>2. 将一个成员定义成mutable即可被常量函数修改。
5. 类中的常量const 类型的，不能在类中被用来定义数组。而enum {ONE=100; TWO=2};定义的ONE、TWO 却可以。通常的enum定义的置分配问题：enum A{ L=9, Z};此时Z的值为10。

## 类中const和statoc数据成员的初始化



> https://blog.csdn.net/tobefxz/article/details/14109697



```cpp
class Test{
public:
	Test():a(0){}
	enum {size1=100,size2=200};
private:
	const int a;//只能在构造函数初始化列表中初始化
	static int b;//在类的实现文件中定义并初始化
	conststatic int c;//与 static const int c;相同。
};
 
int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。
cosnt intTest::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。
```



























